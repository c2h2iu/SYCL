
        <!DOCTYPE html>
        <html>
            <head>
                <link rel="stylesheet" type="text/css" href="file:///C:/Users/Graham/Documents/product-release-agent-guides/document-style.css" />
                <title>Hello SYCL</title>
                <meta charset="UTF-8">
            </head>
            <body>
                <h1>Hello SYCL</h1>
                <main>
<p>At this point we assume that you have set up the pre-requisites for developing using ComputeCpp and we will proceed by writing our first SYCL application.</p>
<p><strong>'Hello SYCL'</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

  <span class="cp">#include</span> <span class="cpf">&lt;CL/sycl.hpp&gt;</span><span class="cp"></span>

  <span class="k">namespace</span> <span class="n">sycl</span> <span class="o">=</span> <span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">&lt;&lt;</span><span class="n">Setup</span> <span class="n">host</span> <span class="n">storage</span><span class="o">&gt;&gt;</span>

    <span class="o">&lt;&lt;</span><span class="n">Initialize</span> <span class="n">device</span> <span class="n">selector</span><span class="o">&gt;&gt;</span>

    <span class="o">&lt;&lt;</span><span class="n">Initialize</span> <span class="n">queue</span><span class="o">&gt;&gt;</span>

    <span class="p">{</span>
      <span class="o">&lt;&lt;</span><span class="n">Setup</span> <span class="n">device</span> <span class="n">storage</span><span class="o">&gt;&gt;</span>

      <span class="o">&lt;&lt;</span><span class="n">Execute</span> <span class="n">kernel</span><span class="o">&gt;&gt;</span>
    <span class="p">}</span>

    <span class="o">&lt;&lt;</span><span class="n">Print</span> <span class="n">results</span><span class="o">&gt;&gt;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</code></pre>
<p>The first thing we do is include the universal SYCL header. You only ever need to use this one header - it provides the entire <code>cl::sycl</code> namespace. For ease of use, we will rename the namespace to just <code>sycl</code>. This will be quicker to type, while still avoiding any name conflicts.</p>
<p><strong>Setup host storage</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
  <span class="n">sycl</span><span class="o">::</span><span class="n">float4</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
  <span class="n">sycl</span><span class="o">::</span><span class="n">float4</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">};</span>
</pre></div>
</code></pre>
<p>In <code>main</code>, we begin by setting up host storage for the data that we want to operate on. Our goal is to compute <code>c = a + b</code>, where the variables are vectors. To help us achieve this, the API provides the <code>vec&lt;T, size&gt;</code> type, which is a vector of a basic scalar type. It has template parameters for the scalar type and the size. It is meant to be used more like a geometrical vector than <code>std::vector</code>, and so it only supports sizes of up to 16. But dont despair, there are plenty of ways to work on larger sets of data, which well see later. We use <code>float4</code>, which is just <code>vec&lt;float, 4&gt;</code>.</p>
<p><strong>Initialize device selector</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">sycl</span><span class="o">::</span><span class="n">default_selector</span> <span class="n">device_selector</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>The SYCL model is built on top of the OpenCL model, so if you have experience with that API, you should be familar with most of the terms used here. In the SYCL model, a computer consists of a <strong>host</strong> (the CPU) connected to zero or more OpenCL <strong>devices</strong>. Devices are made available to the user through <strong>platforms</strong> - for example, a vendor specific driver might be a platform exposing that vendors GPU and CPU as OpenCL devices.</p>
<p>To do anything on the device side, we need to have some representation of the device. SYCL provides a set of classes called <strong>selectors</strong>, which are used to choose platforms and devices. Here, we initialize a <code>default_selector</code>, which uses heuristics to find the most performant device of any type in a common configuration. If there is an accelerator (GPU, FPGA, ..) available, it will most likely select that, otherwise it will select the CPU.</p>
<p><strong>Initialize queue</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span> <span class="n">queue</span><span class="p">(</span><span class="n">device_selector</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Running on "</span>
        <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>After that, we initialize a <strong>queue</strong> with the device that the selector chooses. A SYCL queue encapsulates all states necessary for execution. This includes an OpenCL context, platform and device to be used.</p>
<p><strong>Setup device storage</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">sycl</span><span class="o">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">a_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">sycl</span><span class="o">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">b_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">sycl</span><span class="o">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">c_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</code></pre>
<p>On most systems, the host and the device do not share physical memory. For example, the CPU might use RAM and the GPU might use its own on-die VRAM. SYCL needs to know which data it will be sharing between the host and the devices.</p>
<p>For this purpose, SYCL <strong>buffers</strong> exist. The <code>buffer&lt;T, dims&gt;</code> class is generic over the element type and the number of dimensions, which can be one, two or three. When passed a raw pointer like in this case, the <code>buffer(T* ptr, range size)</code> constructor takes ownership of the memory it has been passed. This means that we absolutely cannot use that memory ourselves while the <code>buffer</code> exists, which is why we begin a C++ scope. At the end of their scope, the buffers will be destroyed and the memory returned to the user. The size argument is a <code>range&lt;dims&gt;</code> object, which has to have the same number of dimensions as the buffer and is initialized with the number of elements in each dimension. Here, we have one dimension with one element.</p>
<p>Buffers are not associated with a particular queue or context, so they are capable of handling data transparently between multiple devices. They also do not require read/write information, as this is specified per operation.</p>
<p><strong>Execute kernel</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="o">&amp;</span> <span class="n">cgh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">a_acc</span> <span class="o">=</span> <span class="n">a_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">b_acc</span> <span class="o">=</span> <span class="n">b_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">c_acc</span> <span class="o">=</span> <span class="n">c_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">discard_write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

    <span class="n">cgh</span><span class="p">.</span><span class="n">single_task</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">vector_addition</span><span class="o">&gt;</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
      <span class="n">c_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">});</span>
  <span class="p">});</span>
</pre></div>
</code></pre>
<p>This part is a little complicated, so let us go over it in more detail. The whole thing is technically a single function call to <code>queue::submit</code>. <code>submit</code> accepts a function object parameter, which encapsulates a <strong>command group</strong>. For this purpose, the function object accepts a command group <code>handler</code> constructed by the SYCL runtime and handed to us as the argument. All operations using a given command group handler are part of the same command group.</p>
<p>Note that the command group lambda captures by reference. This is fine, even though, as we will see later, kernel execution is asynchronous. The SYCL specification effectively guarantees that the host-side part of the command group will finish before the call to <code>submit</code> exits - otherwise a referenced variable could be modified. Its only the device-side part that can continue executing afterwards.</p>
<p>In general, the lambda doesnt have to capture by reference - it could also capture by value. For SYCL objects in particular, this will be valid and have very little overhead. The specification requires that a copy of any SYCL object refers to the same underlying resource. Nevertheless, capturing by reference is recommended as better practice in this case to avoid the unnecessary copies.</p>
<p>A command group is a way to encapsulate a device-side operation and all its data dependencies in a single object by grouping all the related commands (function calls). Effectively, what this achieves is preventing data race conditions, resource leaking and other problems by letting the SYCL runtime know the prerequisites for executing device-side code correctly. Generally, it is a bad idea to try to move resources constructed within a command group out of the lambda scope, and the SYCL specification prevents it with move semantics.</p>
<p>In our command group, we first setup <strong>accessors</strong>. In general, these objects define the inputs and outputs of a device-side operation. The accessors also provide access to various forms of memory. In this case, they allow us to access the memory owned by the buffers created earlier. Remember that we passed ownership of our data to the buffer, so we can no longer use the <code>float4</code> objects, and accessors are the only way to access data in <code>buffer</code> objects. The <code>buffer::get_access(handler&amp;)</code> method has two template parameters, the second one taking a default value.</p>
<p>The first is an access mode. We use <code>access::mode::read</code> for the arguments and <code>access::mode::discard_write</code> for the result. <code>discard_write</code> can be used whenever we write to the whole buffer and do not care about its previous contents. Since it will be overwritten entirely, we can discard whatever was there before.</p>
<p>The second parameter is the type of memory we want to access the data from. We will see the available types of memory in the section on memory accesses. For now we use the default value.</p>
<p>Finally, we submit a <strong>kernel</strong> function object to the command group. The kernel is code that will be executed on the device, and thus (hopefully) accelerated. There are a few ways to do this, and <code>single_task</code> is the simplest - as the name suggests, the kernel is executed once. Note that the kernel lambda has to capture by value.</p>
<p>Inside the kernel, we perform vector addition. The accessor class overloads <code>operator[] (size_t i)</code>, which returns a reference to the i-th element in the buffer. Note that since our buffer has <code>float4</code> elements, the 0-th element is actually an entire vector rather than a single <code>float</code>. The <code>vec</code> class overloads various operators, in this case <code>operator+</code> for per-element addition.</p>
<p>One thing that stands out is the <code>class vector_addition</code> template parameter. As is described in the CMake integration guide, the SYCL file has to be compiled with both the host and device compiler. We now know why - this bit of C++ code will be executed on an OpenCL device, so it needs to be compiled to machine code for that device.</p>
<p>The device compiler has to be able to find the C++ code that it needs, and a lambda expression doesnt have a well-defined name. For this reason, we need to supply a dummy class name as a template parameter. The class has to be unique per kernel. Here we forward declare it in the invocation. We will see later that we can avoid this by defining our own function objects.</p>
<p>In general, submitting a kernel is the last thing you should do inside a command group. You have to submit exactly one kernel per group (per <code>submit</code> call).</p>
<p>Execution of most things in SYCL is asynchronous. <code>submit</code> returns immediately and begins executing the command group afterwards. There is no guarantee as to when it will be finished - for this, we need explicit synchronization. Here, we do it the RAII way - we end the buffer scope. The specification guarantees that after the buffers are destroyed, all operations using them will have finished. They release ownership of the vectors back to the user. Under the hood, we can expect the SYCL runtime to wait for device operations to complete and a memory transfer to occur from device to host memory. While for the most part SYCL abstracts away manual memory management, its still important to be aware of when and how memory transfers are executed. They are slow and often a bottleneck of accelerated applications, so its best to try to do as few of them as possible. We will see how to do this in later sections.</p>
<p>Instead of relying on scopes, we could also create host-side accessors. These would force a synchronization and memory transfer back onto the host similarly to the buffer destructor, and choosing how to read memory back is up to the user.</p>
<p><strong>Print results</strong></p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  A { "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" }</span><span class="se">\n</span><span class="s">"</span>
        <span class="o">&lt;&lt;</span> <span class="s">"+ B { "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" }</span><span class="se">\n</span><span class="s">"</span>
        <span class="o">&lt;&lt;</span> <span class="s">"------------------</span><span class="se">\n</span><span class="s">"</span>
        <span class="o">&lt;&lt;</span> <span class="s">"= C { "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" }"</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Finally, we print our results. The output on the machine that built this guide is:</p>
<p>Running on Intel(R) HD Graphics
 A { 1, 2, 3, 4 }
+ B { 4, 3, 2, 1 }
= C { 5, 5, 5, 5 }</p></main>
            </body>
        </html>
        